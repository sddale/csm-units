\hypertarget{fmt_8h_source}{}\doxysection{fmt.\+h}
\label{fmt_8h_source}\index{csm-\/units/units/src/core-\/fmt/include/units/bits/fmt.h@{csm-\/units/units/src/core-\/fmt/include/units/bits/fmt.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ The\ MIT\ License\ (MIT)}}
\DoxyCodeLine{00002\ \textcolor{comment}{//}}
\DoxyCodeLine{00003\ \textcolor{comment}{//\ Copyright\ (c)\ 2018\ Mateusz\ Pusz}}
\DoxyCodeLine{00004\ \textcolor{comment}{//}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ Permission\ is\ hereby\ granted,\ free\ of\ charge,\ to\ any\ person\ obtaining\ a\ copy}}
\DoxyCodeLine{00006\ \textcolor{comment}{//\ of\ this\ software\ and\ associated\ documentation\ files\ (the\ "{}Software"{}),\ to\ deal}}
\DoxyCodeLine{00007\ \textcolor{comment}{//\ in\ the\ Software\ without\ restriction,\ including\ without\ limitation\ the\ rights}}
\DoxyCodeLine{00008\ \textcolor{comment}{//\ to\ use,\ copy,\ modify,\ merge,\ publish,\ distribute,\ sublicense,\ and/or\ sell}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ copies\ of\ the\ Software,\ and\ to\ permit\ persons\ to\ whom\ the\ Software\ is}}
\DoxyCodeLine{00010\ \textcolor{comment}{//\ furnished\ to\ do\ so,\ subject\ to\ the\ following\ conditions:}}
\DoxyCodeLine{00011\ \textcolor{comment}{//}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ The\ above\ copyright\ notice\ and\ this\ permission\ notice\ shall\ be\ included\ in\ all}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ copies\ or\ substantial\ portions\ of\ the\ Software.}}
\DoxyCodeLine{00014\ \textcolor{comment}{//}}
\DoxyCodeLine{00015\ \textcolor{comment}{//\ THE\ SOFTWARE\ IS\ PROVIDED\ "{}AS\ IS"{},\ WITHOUT\ WARRANTY\ OF\ ANY\ KIND,\ EXPRESS\ OR}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ IMPLIED,\ INCLUDING\ BUT\ NOT\ LIMITED\ TO\ THE\ WARRANTIES\ OF\ MERCHANTABILITY,}}
\DoxyCodeLine{00017\ \textcolor{comment}{//\ FITNESS\ FOR\ A\ PARTICULAR\ PURPOSE\ AND\ NONINFRINGEMENT.\ IN\ NO\ EVENT\ SHALL\ THE}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ AUTHORS\ OR\ COPYRIGHT\ HOLDERS\ BE\ LIABLE\ FOR\ ANY\ CLAIM,\ DAMAGES\ OR\ OTHER}}
\DoxyCodeLine{00019\ \textcolor{comment}{//\ LIABILITY,\ WHETHER\ IN\ AN\ ACTION\ OF\ CONTRACT,\ TORT\ OR\ OTHERWISE,\ ARISING\ FROM,}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ OUT\ OF\ OR\ IN\ CONNECTION\ WITH\ THE\ SOFTWARE\ OR\ THE\ USE\ OR\ OTHER\ DEALINGS\ IN\ THE}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ SOFTWARE.}}
\DoxyCodeLine{00022\ }
\DoxyCodeLine{00023\ \textcolor{comment}{//\ Formatting\ library\ for\ C++\ -\/\ the\ core\ API\ for\ char/UTF-\/8}}
\DoxyCodeLine{00024\ \textcolor{comment}{//}}
\DoxyCodeLine{00025\ \textcolor{comment}{//\ Copyright\ (c)\ 2012\ -\/\ present,\ Victor\ Zverovich}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ All\ rights\ reserved.}}
\DoxyCodeLine{00027\ \textcolor{comment}{//}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ For\ the\ license\ information\ refer\ to\ format.h.}}
\DoxyCodeLine{00029\ }
\DoxyCodeLine{00030\ \textcolor{preprocessor}{\#include\ <gsl/gsl-\/lite.hpp>}}
\DoxyCodeLine{00031\ \textcolor{preprocessor}{\#include\ <units/bits/fmt\_hacks.h>}}
\DoxyCodeLine{00032\ \textcolor{preprocessor}{\#include\ <concepts>}}
\DoxyCodeLine{00033\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00034\ \textcolor{preprocessor}{\#include\ <string\_view>}}
\DoxyCodeLine{00035\ }
\DoxyCodeLine{00036\ \textcolor{comment}{//\ most\ of\ the\ below\ code\ is\ based\ on/copied\ from\ libfmt}}
\DoxyCodeLine{00037\ }
\DoxyCodeLine{00038\ \textcolor{keyword}{namespace\ }units::detail\ \{}
\DoxyCodeLine{00039\ }
\DoxyCodeLine{00040\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1auto__id}{auto\_id}}\ \{\};}
\DoxyCodeLine{00041\ }
\DoxyCodeLine{00042\ \textcolor{keyword}{enum\ class}\ fmt\_align\ \{\ none,\ left,\ right,\ center\ \};}
\DoxyCodeLine{00043\ \textcolor{keyword}{enum\ class}\ fmt\_sign\ \{\ none,\ minus,\ plus,\ space\ \};}
\DoxyCodeLine{00044\ \textcolor{keyword}{enum\ class}\ arg\_id\_kind\ \{\ none,\ index,\ name\ \};}
\DoxyCodeLine{00045\ }
\DoxyCodeLine{00046\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00047\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1fill__t}{fill\_t}}\ \{}
\DoxyCodeLine{00048\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00049\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ max\_size\ =\ 4\ /\ \textcolor{keyword}{sizeof}(Char);}
\DoxyCodeLine{00050\ \ \ \textcolor{comment}{//\ At\ most\ one\ codepoint\ (so\ one\ char32\_t\ or\ four\ utf-\/8\ char8\_t)}}
\DoxyCodeLine{00051\ \ \ Char\ data\_[max\_size]\ =\ \{Char\{\textcolor{charliteral}{'\ '}\}\};}
\DoxyCodeLine{00052\ \ \ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\ size\_\ =\ 1;}
\DoxyCodeLine{00053\ }
\DoxyCodeLine{00054\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00055\ \ \ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{structunits_1_1detail_1_1fill__t}{fill\_t}}\&\ operator=(std::basic\_string\_view<Char>\ str)}
\DoxyCodeLine{00056\ \ \ \{}
\DoxyCodeLine{00057\ \ \ \ \ \textcolor{keyword}{auto}\ size\ =\ str.size();}
\DoxyCodeLine{00058\ \ \ \ \ \textcolor{keywordflow}{if}\ (size\ >\ max\_size)\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ fill"{}}));}
\DoxyCodeLine{00059\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ size;\ ++i)\ data\_[i]\ =\ str[i];}
\DoxyCodeLine{00060\ \ \ \ \ size\_\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{00061\ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{00062\ \ \ \}}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ size()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ size\_;\ \}}
\DoxyCodeLine{00065\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{const}\ Char*\ \mbox{\hyperlink{structdata}{data}}()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ data\_;\ \}}
\DoxyCodeLine{00066\ }
\DoxyCodeLine{00067\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ Char\&\ operator[](\textcolor{keywordtype}{size\_t}\ index)\ \{\ \textcolor{keywordflow}{return}\ data\_[index];\ \}}
\DoxyCodeLine{00068\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{const}\ Char\&\ operator[](\textcolor{keywordtype}{size\_t}\ index)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ data\_[index];\ \}}
\DoxyCodeLine{00069\ \};}
\DoxyCodeLine{00070\ }
\DoxyCodeLine{00071\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00072\ \textcolor{keyword}{inline}\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ is\_integer\ =\ std::is\_integral<T>::value\ \&\&\ !std::is\_same<T,\ bool>::value\ \&\&}
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_same<T,\ char>::value\ \&\&\ !std::is\_same<T,\ wchar\_t>::value;}
\DoxyCodeLine{00074\ }
\DoxyCodeLine{00075\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00076\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ is\_ascii\_letter(Char\ c)}
\DoxyCodeLine{00077\ \{}
\DoxyCodeLine{00078\ \ \ \textcolor{keywordflow}{return}\ (c\ >=\ \textcolor{charliteral}{'a'}\ \&\&\ c\ <=\ \textcolor{charliteral}{'z'})\ ||\ (c\ >=\ \textcolor{charliteral}{'A'}\ \&\&\ c\ <=\ \textcolor{charliteral}{'Z'});}
\DoxyCodeLine{00079\ \}}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ \textcolor{comment}{//\ Converts\ a\ character\ to\ ASCII.\ Returns\ a\ number\ >\ 127\ on\ conversion\ failure.}}
\DoxyCodeLine{00082\ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{int}egral\ Char>}
\DoxyCodeLine{00083\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ Char\ to\_ascii(Char\ value)}
\DoxyCodeLine{00084\ \{}
\DoxyCodeLine{00085\ \ \ \textcolor{keywordflow}{return}\ value;}
\DoxyCodeLine{00086\ \}}
\DoxyCodeLine{00087\ }
\DoxyCodeLine{00088\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00089\ \ \ \textcolor{keyword}{requires}\ std::is\_enum\_v<Char>}
\DoxyCodeLine{00090\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ to\_ascii(Char\ value)\ -\/>\ std::underlying\_type\_t<Char>}
\DoxyCodeLine{00091\ \{}
\DoxyCodeLine{00092\ \ \ \textcolor{keywordflow}{return}\ value;}
\DoxyCodeLine{00093\ \}}
\DoxyCodeLine{00094\ }
\DoxyCodeLine{00095\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1width__checker}{width\_checker}}\ \{}
\DoxyCodeLine{00096\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00097\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ operator()(T\ value)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00098\ \textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{00099\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (is\_integer<T>)\ \{}
\DoxyCodeLine{00100\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (std::numeric\_limits<T>::is\_signed)\ \{}
\DoxyCodeLine{00101\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ <\ 0)\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}negative\ width"{}}));}
\DoxyCodeLine{00102\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00103\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{00104\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00105\ \ \ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}width\ is\ not\ integer"{}}));}
\DoxyCodeLine{00106\ \ \ \ \ \}}
\DoxyCodeLine{00107\ \ \ \}}
\DoxyCodeLine{00108\ \};}
\DoxyCodeLine{00109\ }
\DoxyCodeLine{00110\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1precision__checker}{precision\_checker}}\ \{}
\DoxyCodeLine{00111\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00112\ \ \ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ operator()(T\ value)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00113\ \textcolor{keyword}{\ \ }\{}
\DoxyCodeLine{00114\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (is\_integer<T>)\ \{}
\DoxyCodeLine{00115\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (std::numeric\_limits<T>::is\_signed)\ \{}
\DoxyCodeLine{00116\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ <\ 0)\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}negative\ precision"{}}));}
\DoxyCodeLine{00117\ \ \ \ \ \ \ \}}
\DoxyCodeLine{00118\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{00119\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00120\ \ \ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}precision\ is\ not\ integer"{}}));}
\DoxyCodeLine{00121\ \ \ \ \ \}}
\DoxyCodeLine{00122\ \ \ \}}
\DoxyCodeLine{00123\ \};}
\DoxyCodeLine{00124\ }
\DoxyCodeLine{00125\ \textcolor{comment}{//\ Format\ specifiers\ for\ built-\/in\ and\ string\ types.}}
\DoxyCodeLine{00126\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00127\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1basic__format__specs}{basic\_format\_specs}}\ \{}
\DoxyCodeLine{00128\ \ \ \textcolor{keywordtype}{int}\ width\ =\ 0;}
\DoxyCodeLine{00129\ \ \ \textcolor{keywordtype}{int}\ precision\ =\ -\/1;}
\DoxyCodeLine{00130\ \ \ \textcolor{keywordtype}{char}\ type\ =\ \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{00131\ \ \ fmt\_align\ align\ :\ 4\ =\ fmt\_align::none;}
\DoxyCodeLine{00132\ \ \ fmt\_sign\ sign\ :\ 3\ =\ fmt\_sign::none;}
\DoxyCodeLine{00133\ \ \ \textcolor{keywordtype}{bool}\ alt\ :\ 1\ =\ \textcolor{keyword}{false};\ \ \textcolor{comment}{//\ Alternate\ form\ ('\#').}}
\DoxyCodeLine{00134\ \ \ \textcolor{keywordtype}{bool}\ localized\ :\ 1\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00135\ \ \ \mbox{\hyperlink{structunits_1_1detail_1_1fill__t}{fill\_t<Char>}}\ fill;}
\DoxyCodeLine{00136\ \};}
\DoxyCodeLine{00137\ }
\DoxyCodeLine{00138\ \textcolor{comment}{//\ Format\ specifiers\ with\ width\ and\ precision\ resolved\ at\ formatting\ rather}}
\DoxyCodeLine{00139\ \textcolor{comment}{//\ than\ parsing\ time\ to\ allow\ re-\/using\ the\ same\ parsed\ specifiers\ with}}
\DoxyCodeLine{00140\ \textcolor{comment}{//\ different\ sets\ of\ arguments\ (precompilation\ of\ format\ strings).}}
\DoxyCodeLine{00141\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00142\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structunits_1_1detail_1_1dynamic__format__specs}{dynamic\_format\_specs}}\ :\ \mbox{\hyperlink{structunits_1_1detail_1_1basic__format__specs}{basic\_format\_specs}}<Char>\ \{}
\DoxyCodeLine{00143\ \ \ \textcolor{keywordtype}{int}\ dynamic\_width\_index\ =\ -\/1;}
\DoxyCodeLine{00144\ \ \ \textcolor{keywordtype}{int}\ dynamic\_precision\_index\ =\ -\/1;}
\DoxyCodeLine{00145\ \};}
\DoxyCodeLine{00146\ }
\DoxyCodeLine{00147\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{int}\ verify\_dynamic\_arg\_index\_in\_range(\textcolor{keywordtype}{size\_t}\ idx)}
\DoxyCodeLine{00148\ \{}
\DoxyCodeLine{00149\ \ \ \textcolor{keywordflow}{if}\ (idx\ >\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(std::numeric\_limits<int>::max()))\ \{}
\DoxyCodeLine{00150\ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}Dynamic\ width\ or\ precision\ index\ too\ large."{}}));}
\DoxyCodeLine{00151\ \ \ \}}
\DoxyCodeLine{00152\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(idx);}
\DoxyCodeLine{00153\ \}}
\DoxyCodeLine{00154\ }
\DoxyCodeLine{00155\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ CharT>}
\DoxyCodeLine{00156\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{int}\ on\_dynamic\_arg(\textcolor{keywordtype}{size\_t}\ arg\_id,\ UNITS\_STD\_FMT::basic\_format\_parse\_context<CharT>\&\ context)}
\DoxyCodeLine{00157\ \{}
\DoxyCodeLine{00158\ \ \ context.check\_arg\_id(UNITS\_FMT\_TO\_ARG\_ID(arg\_id));}
\DoxyCodeLine{00159\ \ \ \textcolor{keywordflow}{return}\ verify\_dynamic\_arg\_index\_in\_range(arg\_id);}
\DoxyCodeLine{00160\ \}}
\DoxyCodeLine{00161\ }
\DoxyCodeLine{00162\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ CharT>}
\DoxyCodeLine{00163\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{int}\ on\_dynamic\_arg(auto\_id,\ UNITS\_STD\_FMT::basic\_format\_parse\_context<CharT>\&\ context)}
\DoxyCodeLine{00164\ \{}
\DoxyCodeLine{00165\ \ \ \textcolor{keywordflow}{return}\ verify\_dynamic\_arg\_index\_in\_range(UNITS\_FMT\_FROM\_ARG\_ID(context.next\_arg\_id()));}
\DoxyCodeLine{00166\ \}}
\DoxyCodeLine{00167\ }
\DoxyCodeLine{00168\ \textcolor{keyword}{template}<\textcolor{keyword}{class}\ Handler,\ \textcolor{keyword}{typename}\ FormatContext>}
\DoxyCodeLine{00169\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{int}\ get\_dynamic\_spec(\textcolor{keywordtype}{int}\ index,\ FormatContext\&\ ctx)}
\DoxyCodeLine{00170\ \{}
\DoxyCodeLine{00171\ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\ value\ =}
\DoxyCodeLine{00172\ \ \ \ \ UNITS\_STD\_FMT::visit\_format\_arg(Handler\{\},\ ctx.arg(UNITS\_FMT\_TO\_ARG\_ID(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(index))));}
\DoxyCodeLine{00173\ \ \ \textcolor{keywordflow}{if}\ (value\ >\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{long}\ \textcolor{keywordtype}{long}\textcolor{keyword}{>}(std::numeric\_limits<int>::max()))\ \{}
\DoxyCodeLine{00174\ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}number\ is\ too\ big"{}}));}
\DoxyCodeLine{00175\ \ \ \}}
\DoxyCodeLine{00176\ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{00177\ \}}
\DoxyCodeLine{00178\ }
\DoxyCodeLine{00179\ \textcolor{comment}{//\ Parses\ the\ range\ [begin,\ end)\ as\ an\ unsigned\ integer.\ This\ function\ assumes}}
\DoxyCodeLine{00180\ \textcolor{comment}{//\ that\ the\ range\ is\ non-\/empty\ and\ the\ first\ character\ is\ a\ digit.}}
\DoxyCodeLine{00181\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S>}
\DoxyCodeLine{00182\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_nonnegative\_int(It\ begin,\ S\ end,\ \textcolor{keywordtype}{size\_t}\&\ value)}
\DoxyCodeLine{00183\ \{}
\DoxyCodeLine{00184\ \ \ gsl\_Expects(begin\ !=\ end\ \&\&\ \textcolor{charliteral}{'0'}\ <=\ *begin\ \&\&\ *begin\ <=\ \textcolor{charliteral}{'9'});}
\DoxyCodeLine{00185\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ max\_int\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(std::numeric\_limits<int>::max());}
\DoxyCodeLine{00186\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ big\_int\ =\ max\_int\ /\ 10u;}
\DoxyCodeLine{00187\ \ \ value\ =\ 0;}
\DoxyCodeLine{00188\ }
\DoxyCodeLine{00189\ \ \ \textcolor{keywordflow}{do}\ \{}
\DoxyCodeLine{00190\ \ \ \ \ \textcolor{keywordflow}{if}\ (value\ >\ big\_int)\ \{}
\DoxyCodeLine{00191\ \ \ \ \ \ \ value\ =\ max\_int\ +\ 1;}
\DoxyCodeLine{00192\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00193\ \ \ \ \ \}}
\DoxyCodeLine{00194\ \ \ \ \ value\ =\ value\ *\ 10\ +\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{int}\textcolor{keyword}{>}(*begin\ -\/\ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{00195\ \ \ \ \ ++begin;}
\DoxyCodeLine{00196\ \ \ \}\ \textcolor{keywordflow}{while}\ (begin\ !=\ end\ \&\&\ \textcolor{charliteral}{'0'}\ <=\ *begin\ \&\&\ *begin\ <=\ \textcolor{charliteral}{'9'});}
\DoxyCodeLine{00197\ }
\DoxyCodeLine{00198\ \ \ \textcolor{keywordflow}{if}\ (value\ >\ max\_int)\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}Number\ is\ too\ big"{}}));}
\DoxyCodeLine{00199\ }
\DoxyCodeLine{00200\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00201\ \}}
\DoxyCodeLine{00202\ }
\DoxyCodeLine{00203\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S>}
\DoxyCodeLine{00204\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_nonnegative\_int(It\ begin,\ S\ end,\ \textcolor{keywordtype}{int}\&\ value)}
\DoxyCodeLine{00205\ \{}
\DoxyCodeLine{00206\ \ \ \textcolor{keywordtype}{size\_t}\ val\_unsigned\ =\ 0;}
\DoxyCodeLine{00207\ \ \ begin\ =\ parse\_nonnegative\_int(begin,\ end,\ val\_unsigned);}
\DoxyCodeLine{00208\ \ \ \textcolor{comment}{//\ Never\ invalid\ because\ parse\_nonnegative\_integer\ throws\ an\ error\ for\ values\ that\ don't\ fit\ in\ signed\ integers}}
\DoxyCodeLine{00209\ \ \ value\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(val\_unsigned);}
\DoxyCodeLine{00210\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00211\ \}}
\DoxyCodeLine{00212\ }
\DoxyCodeLine{00213\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ IDHandler>}
\DoxyCodeLine{00214\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ do\_parse\_arg\_id(It\ begin,\ S\ end,\ IDHandler\&\&\ handler)}
\DoxyCodeLine{00215\ \{}
\DoxyCodeLine{00216\ \ \ gsl\_Expects(begin\ !=\ end);}
\DoxyCodeLine{00217\ \ \ \textcolor{keyword}{auto}\ c\ =\ *begin;}
\DoxyCodeLine{00218\ \ \ \textcolor{keywordflow}{if}\ (c\ >=\ \textcolor{charliteral}{'0'}\ \&\&\ c\ <=\ \textcolor{charliteral}{'9'})\ \{}
\DoxyCodeLine{00219\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ index\ =\ 0;}
\DoxyCodeLine{00220\ \ \ \ \ \textcolor{keywordflow}{if}\ (c\ !=\ \textcolor{charliteral}{'0'})}
\DoxyCodeLine{00221\ \ \ \ \ \ \ begin\ =\ parse\_nonnegative\_int(begin,\ end,\ index);}
\DoxyCodeLine{00222\ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00223\ \ \ \ \ \ \ ++begin;}
\DoxyCodeLine{00224\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end\ ||\ (*begin\ !=\ \textcolor{charliteral}{'\}'}\ \&\&\ *begin\ !=\ \textcolor{charliteral}{':'}))}
\DoxyCodeLine{00225\ \ \ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ format\ string"{}}));}
\DoxyCodeLine{00226\ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00227\ \ \ \ \ \ \ handler(index);}
\DoxyCodeLine{00228\ \ \ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00229\ \ \ \}}
\DoxyCodeLine{00230\ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ format\ string"{}}));}
\DoxyCodeLine{00231\ \}}
\DoxyCodeLine{00232\ }
\DoxyCodeLine{00233\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ IDHandler>}
\DoxyCodeLine{00234\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_arg\_id(It\ begin,\ S\ end,\ IDHandler\&\&\ handler)}
\DoxyCodeLine{00235\ \{}
\DoxyCodeLine{00236\ \ \ \textcolor{keyword}{auto}\ c\ =\ *begin;}
\DoxyCodeLine{00237\ \ \ \textcolor{keywordflow}{if}\ (c\ !=\ \textcolor{charliteral}{'\}'}\ \&\&\ c\ !=\ \textcolor{charliteral}{':'})\ \textcolor{keywordflow}{return}\ do\_parse\_arg\_id(begin,\ end,\ handler);}
\DoxyCodeLine{00238\ \ \ handler();}
\DoxyCodeLine{00239\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00240\ \}}
\DoxyCodeLine{00241\ }
\DoxyCodeLine{00242\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ Handler>}
\DoxyCodeLine{00243\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_sign(It\ begin,\ S\ end,\ Handler\&\&\ handler)}
\DoxyCodeLine{00244\ \{}
\DoxyCodeLine{00245\ \ \ gsl\_Expects(begin\ !=\ end);}
\DoxyCodeLine{00246\ \ \ \textcolor{keywordflow}{switch}\ (to\_ascii(*begin))\ \{}
\DoxyCodeLine{00247\ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{00248\ \ \ \ \ \ \ handler.on\_sign(fmt\_sign::plus);}
\DoxyCodeLine{00249\ \ \ \ \ \ \ ++begin;}
\DoxyCodeLine{00250\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00251\ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{00252\ \ \ \ \ \ \ handler.on\_sign(fmt\_sign::minus);}
\DoxyCodeLine{00253\ \ \ \ \ \ \ ++begin;}
\DoxyCodeLine{00254\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00255\ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'\ '}:}
\DoxyCodeLine{00256\ \ \ \ \ \ \ handler.on\_sign(fmt\_sign::space);}
\DoxyCodeLine{00257\ \ \ \ \ \ \ ++begin;}
\DoxyCodeLine{00258\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00259\ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00260\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00261\ \ \ \}}
\DoxyCodeLine{00262\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00263\ \}}
\DoxyCodeLine{00264\ }
\DoxyCodeLine{00265\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ Handler>}
\DoxyCodeLine{00266\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_width(It\ begin,\ S\ end,\ Handler\&\&\ handler)}
\DoxyCodeLine{00267\ \{}
\DoxyCodeLine{00268\ \ \ \textcolor{keyword}{struct\ }width\_adapter\ \{}
\DoxyCodeLine{00269\ \ \ \ \ Handler\&\ handler;}
\DoxyCodeLine{00270\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ operator()()\ \{\ handler.on\_dynamic\_width(auto\_id\{\});\ \}}
\DoxyCodeLine{00271\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ operator()(\textcolor{keywordtype}{size\_t}\ \textcolor{keywordtype}{id})\ \{\ handler.on\_dynamic\_width(\textcolor{keywordtype}{id});\ \}}
\DoxyCodeLine{00272\ \ \ \};}
\DoxyCodeLine{00273\ }
\DoxyCodeLine{00274\ \ \ gsl\_Expects(begin\ !=\ end);}
\DoxyCodeLine{00275\ \ \ \textcolor{keywordflow}{if}\ (\textcolor{charliteral}{'0'}\ <=\ *begin\ \&\&\ *begin\ <=\ \textcolor{charliteral}{'9'})\ \{}
\DoxyCodeLine{00276\ \ \ \ \ \textcolor{keywordtype}{int}\ width\ =\ 0;}
\DoxyCodeLine{00277\ \ \ \ \ begin\ =\ parse\_nonnegative\_int(begin,\ end,\ width);}
\DoxyCodeLine{00278\ \ \ \ \ \textcolor{keywordflow}{if}\ (width\ !=\ -\/1)}
\DoxyCodeLine{00279\ \ \ \ \ \ \ handler.on\_width(width);}
\DoxyCodeLine{00280\ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00281\ \ \ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}number\ is\ too\ big"{}}));}
\DoxyCodeLine{00282\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (*begin\ ==\ \textcolor{charliteral}{'\{'})\ \{}
\DoxyCodeLine{00283\ \ \ \ \ ++begin;}
\DoxyCodeLine{00284\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ !=\ end)\ begin\ =\ parse\_arg\_id(begin,\ end,\ width\_adapter\{handler\});}
\DoxyCodeLine{00285\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end\ ||\ *begin\ !=\ \textcolor{charliteral}{'\}'})\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ format\ string"{}}));}
\DoxyCodeLine{00286\ \ \ \ \ ++begin;}
\DoxyCodeLine{00287\ \ \ \}}
\DoxyCodeLine{00288\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00289\ \}}
\DoxyCodeLine{00290\ }
\DoxyCodeLine{00291\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ Handler>}
\DoxyCodeLine{00292\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_precision(It\ begin,\ S\ end,\ Handler\&\&\ handler)}
\DoxyCodeLine{00293\ \{}
\DoxyCodeLine{00294\ \ \ \textcolor{keyword}{struct\ }precision\_adapter\ \{}
\DoxyCodeLine{00295\ \ \ \ \ Handler\&\ handler;}
\DoxyCodeLine{00296\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ operator()()\ \{\ handler.on\_dynamic\_precision(auto\_id\{\});\ \}}
\DoxyCodeLine{00297\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ operator()(\textcolor{keywordtype}{size\_t}\ \textcolor{keywordtype}{id})\ \{\ handler.on\_dynamic\_precision(\textcolor{keywordtype}{id});\ \}}
\DoxyCodeLine{00298\ \ \ \};}
\DoxyCodeLine{00299\ }
\DoxyCodeLine{00300\ \ \ ++begin;}
\DoxyCodeLine{00301\ \ \ \textcolor{keyword}{auto}\ c\ =\ begin\ !=\ end\ ?\ *begin\ :\ std::iter\_value\_t<It>();}
\DoxyCodeLine{00302\ \ \ \textcolor{keywordflow}{if}\ (\textcolor{charliteral}{'0'}\ <=\ c\ \&\&\ c\ <=\ \textcolor{charliteral}{'9'})\ \{}
\DoxyCodeLine{00303\ \ \ \ \ \textcolor{keyword}{auto}\ precision\ =\ 0;}
\DoxyCodeLine{00304\ \ \ \ \ begin\ =\ parse\_nonnegative\_int(begin,\ end,\ precision);}
\DoxyCodeLine{00305\ \ \ \ \ \textcolor{keywordflow}{if}\ (precision\ !=\ -\/1)}
\DoxyCodeLine{00306\ \ \ \ \ \ \ handler.on\_precision(precision);}
\DoxyCodeLine{00307\ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00308\ \ \ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}number\ is\ too\ big"{}}));}
\DoxyCodeLine{00309\ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (c\ ==\ \textcolor{charliteral}{'\{'})\ \{}
\DoxyCodeLine{00310\ \ \ \ \ ++begin;}
\DoxyCodeLine{00311\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ !=\ end)\ begin\ =\ parse\_arg\_id(begin,\ end,\ precision\_adapter\{handler\});}
\DoxyCodeLine{00312\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end\ ||\ *begin++\ !=\ \textcolor{charliteral}{'\}'})\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ format\ string"{}}));}
\DoxyCodeLine{00313\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00314\ \ \ \ \ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}missing\ precision\ specifier"{}}));}
\DoxyCodeLine{00315\ \ \ \}}
\DoxyCodeLine{00316\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00317\ \}}
\DoxyCodeLine{00318\ }
\DoxyCodeLine{00319\ \textcolor{keyword}{template}<std::input\_iterator\ It>}
\DoxyCodeLine{00320\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{int}\ code\_point\_length(It\ begin)}
\DoxyCodeLine{00321\ \{}
\DoxyCodeLine{00322\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (\textcolor{keyword}{sizeof}(std::iter\_value\_t<It>)\ !=\ 1)\ \textcolor{keywordflow}{return}\ 1;}
\DoxyCodeLine{00323\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{char}\ lengths[]\ =\ \{1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,}
\DoxyCodeLine{00324\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 0,\ 2,\ 2,\ 2,\ 2,\ 3,\ 3,\ 4,\ 0\};}
\DoxyCodeLine{00325\ \ \ \textcolor{keywordtype}{int}\ len\ =\ lengths[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}\textcolor{keyword}{>}(*begin)\ >>\ 3];}
\DoxyCodeLine{00326\ }
\DoxyCodeLine{00327\ \ \ \textcolor{comment}{//\ Compute\ the\ pointer\ to\ the\ next\ character\ early\ so\ that\ the\ next}}
\DoxyCodeLine{00328\ \ \ \textcolor{comment}{//\ iteration\ can\ start\ working\ on\ the\ next\ character.\ Neither\ Clang}}
\DoxyCodeLine{00329\ \ \ \textcolor{comment}{//\ nor\ GCC\ figure\ out\ this\ reordering\ on\ their\ own.}}
\DoxyCodeLine{00330\ \ \ \textcolor{keywordflow}{return}\ len\ +\ !len;}
\DoxyCodeLine{00331\ \}}
\DoxyCodeLine{00332\ }
\DoxyCodeLine{00333\ \textcolor{comment}{//\ Parses\ fill\ and\ alignment.}}
\DoxyCodeLine{00334\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ Handler>}
\DoxyCodeLine{00335\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_align(It\ begin,\ S\ end,\ Handler\&\&\ handler)}
\DoxyCodeLine{00336\ \{}
\DoxyCodeLine{00337\ \ \ gsl\_Expects(begin\ !=\ end);}
\DoxyCodeLine{00338\ \ \ \textcolor{keyword}{auto}\ align\ =\ fmt\_align::none;}
\DoxyCodeLine{00339\ \ \ \textcolor{keyword}{auto}\ p\ =\ begin\ +\ code\_point\_length(begin);}
\DoxyCodeLine{00340\ \ \ \textcolor{keywordflow}{if}\ (p\ >=\ end)\ p\ =\ begin;}
\DoxyCodeLine{00341\ \ \ \textcolor{keywordflow}{for}\ (;;)\ \{}
\DoxyCodeLine{00342\ \ \ \ \ \textcolor{keywordflow}{switch}\ (to\_ascii(*p))\ \{}
\DoxyCodeLine{00343\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{00344\ \ \ \ \ \ \ \ \ align\ =\ fmt\_align::left;}
\DoxyCodeLine{00345\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00346\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{00347\ \ \ \ \ \ \ \ \ align\ =\ fmt\_align::right;}
\DoxyCodeLine{00348\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00349\ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{00350\ \ \ \ \ \ \ \ \ align\ =\ fmt\_align::center;}
\DoxyCodeLine{00351\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00352\ \ \ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00353\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00354\ \ \ \ \ \}}
\DoxyCodeLine{00355\ \ \ \ \ \textcolor{keywordflow}{if}\ (align\ !=\ fmt\_align::none)\ \{}
\DoxyCodeLine{00356\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (p\ !=\ begin)\ \{}
\DoxyCodeLine{00357\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ c\ =\ *begin;}
\DoxyCodeLine{00358\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (c\ ==\ \textcolor{charliteral}{'\{'})\ UNITS\_THROW(UNITS\_STD\_FMT::format\_error(\textcolor{stringliteral}{"{}invalid\ fill\ character\ '\{'"{}}));}
\DoxyCodeLine{00359\ \ \ \ \ \ \ \ \ handler.on\_fill(std::basic\_string\_view<std::iter\_value\_t<It>>(\&*begin,\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(p\ -\/\ begin)));}
\DoxyCodeLine{00360\ \ \ \ \ \ \ \ \ begin\ =\ p\ +\ 1;}
\DoxyCodeLine{00361\ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00362\ \ \ \ \ \ \ \ \ ++begin;}
\DoxyCodeLine{00363\ \ \ \ \ \ \ handler.on\_align(align);}
\DoxyCodeLine{00364\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00365\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (p\ ==\ begin)\ \{}
\DoxyCodeLine{00366\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00367\ \ \ \ \ \}}
\DoxyCodeLine{00368\ \ \ \ \ p\ =\ begin;}
\DoxyCodeLine{00369\ \ \ \}}
\DoxyCodeLine{00370\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00371\ \}}
\DoxyCodeLine{00372\ }
\DoxyCodeLine{00373\ \textcolor{comment}{//\ Parses\ standard\ format\ specifiers\ and\ sends\ notifications\ about\ parsed}}
\DoxyCodeLine{00374\ \textcolor{comment}{//\ components\ to\ handler.}}
\DoxyCodeLine{00375\ \textcolor{keyword}{template}<std::input\_iterator\ It,\ std::sentinel\_for<It>\ S,\ \textcolor{keyword}{typename}\ SpecHandler>}
\DoxyCodeLine{00376\ [[nodiscard]]\ \textcolor{keyword}{constexpr}\ It\ parse\_format\_specs(It\ begin,\ S\ end,\ SpecHandler\&\&\ handler)}
\DoxyCodeLine{00377\ \{}
\DoxyCodeLine{00378\ \ \ \textcolor{keywordflow}{if}\ (begin\ +\ 1\ <\ end\ \&\&\ begin[1]\ ==\ \textcolor{charliteral}{'\}'}\ \&\&\ is\_ascii\_letter(*begin)\ \&\&\ *begin\ !=\ \textcolor{charliteral}{'L'})\ \{}
\DoxyCodeLine{00379\ \ \ \ \ handler.on\_type(*begin++);}
\DoxyCodeLine{00380\ \ \ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00381\ \ \ \}}
\DoxyCodeLine{00382\ }
\DoxyCodeLine{00383\ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00384\ }
\DoxyCodeLine{00385\ \ \ begin\ =\ ::units::detail::parse\_align(begin,\ end,\ handler);}
\DoxyCodeLine{00386\ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00387\ }
\DoxyCodeLine{00388\ \ \ \textcolor{comment}{//\ Parse\ sign.}}
\DoxyCodeLine{00389\ \ \ begin\ =\ ::units::detail::parse\_sign(begin,\ end,\ handler);}
\DoxyCodeLine{00390\ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00391\ }
\DoxyCodeLine{00392\ \ \ \textcolor{keywordflow}{if}\ (*begin\ ==\ \textcolor{charliteral}{'\#'})\ \{}
\DoxyCodeLine{00393\ \ \ \ \ handler.on\_hash();}
\DoxyCodeLine{00394\ \ \ \ \ \textcolor{keywordflow}{if}\ (++begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00395\ \ \ \}}
\DoxyCodeLine{00396\ }
\DoxyCodeLine{00397\ \ \ \textcolor{comment}{//\ Parse\ zero\ flag.}}
\DoxyCodeLine{00398\ \ \ \textcolor{keywordflow}{if}\ (*begin\ ==\ \textcolor{charliteral}{'0'})\ \{}
\DoxyCodeLine{00399\ \ \ \ \ handler.on\_zero();}
\DoxyCodeLine{00400\ \ \ \ \ \textcolor{keywordflow}{if}\ (++begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00401\ \ \ \}}
\DoxyCodeLine{00402\ }
\DoxyCodeLine{00403\ \ \ begin\ =\ ::units::detail::parse\_width(begin,\ end,\ handler);}
\DoxyCodeLine{00404\ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00405\ }
\DoxyCodeLine{00406\ \ \ \textcolor{comment}{//\ Parse\ precision.}}
\DoxyCodeLine{00407\ \ \ \textcolor{keywordflow}{if}\ (*begin\ ==\ \textcolor{charliteral}{'.'})\ \{}
\DoxyCodeLine{00408\ \ \ \ \ begin\ =\ ::units::detail::parse\_precision(begin,\ end,\ handler);}
\DoxyCodeLine{00409\ \ \ \ \ \textcolor{keywordflow}{if}\ (begin\ ==\ end)\ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00410\ \ \ \}}
\DoxyCodeLine{00411\ }
\DoxyCodeLine{00412\ \ \ \textcolor{keywordflow}{if}\ (*begin\ ==\ \textcolor{charliteral}{'L'})\ \{}
\DoxyCodeLine{00413\ \ \ \ \ handler.on\_localized();}
\DoxyCodeLine{00414\ \ \ \ \ ++begin;}
\DoxyCodeLine{00415\ \ \ \}}
\DoxyCodeLine{00416\ }
\DoxyCodeLine{00417\ \ \ \textcolor{comment}{//\ Parse\ type.}}
\DoxyCodeLine{00418\ \ \ \textcolor{keywordflow}{if}\ (begin\ !=\ end\ \&\&\ *begin\ !=\ \textcolor{charliteral}{'\}'})\ handler.on\_type(*begin++);}
\DoxyCodeLine{00419\ \ \ \textcolor{keywordflow}{return}\ begin;}
\DoxyCodeLine{00420\ \}}
\DoxyCodeLine{00421\ }
\DoxyCodeLine{00422\ \textcolor{comment}{//\ A\ format\ specifier\ handler\ that\ sets\ fields\ in\ basic\_format\_specs.}}
\DoxyCodeLine{00423\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Char>}
\DoxyCodeLine{00424\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classunits_1_1detail_1_1specs__setter}{specs\_setter}}\ \{}
\DoxyCodeLine{00425\ \textcolor{keyword}{protected}:}
\DoxyCodeLine{00426\ \ \ \mbox{\hyperlink{structunits_1_1detail_1_1basic__format__specs}{basic\_format\_specs<Char>}}\&\ specs\_;}
\DoxyCodeLine{00427\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00428\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{classunits_1_1detail_1_1specs__setter}{specs\_setter}}(\mbox{\hyperlink{structunits_1_1detail_1_1basic__format__specs}{basic\_format\_specs<Char>}}\&\ specs)\ :\ specs\_(specs)\ \{\}}
\DoxyCodeLine{00429\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_align(fmt\_align\ align)\ \{\ specs\_.align\ =\ align;\ \}}
\DoxyCodeLine{00430\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_fill(std::basic\_string\_view<Char>\ fill)\ \{\ specs\_.fill\ =\ fill;\ \}}
\DoxyCodeLine{00431\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_sign(fmt\_sign\ s)\ \{\ specs\_.sign\ =\ s;\ \}}
\DoxyCodeLine{00432\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_hash()\ \{\ specs\_.alt\ =\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{00433\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_localized()\ \{\ specs\_.localized\ =\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{00434\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_zero()\ \{\ specs\_.fill[0]\ =\ Char(\textcolor{charliteral}{'0'});\ \}}
\DoxyCodeLine{00435\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_width(\textcolor{keywordtype}{int}\ width)\ \{\ specs\_.width\ =\ width;\ \}}
\DoxyCodeLine{00436\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_precision(\textcolor{keywordtype}{int}\ precision)\ \{\ specs\_.precision\ =\ precision;\ \}}
\DoxyCodeLine{00437\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_type(Char\ type)\ \{\ specs\_.type\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(type);\ \}}
\DoxyCodeLine{00438\ \};}
\DoxyCodeLine{00439\ }
\DoxyCodeLine{00440\ \textcolor{comment}{//\ Format\ spec\ handler\ that\ saves\ references\ to\ arguments\ representing\ dynamic}}
\DoxyCodeLine{00441\ \textcolor{comment}{//\ width\ and\ precision\ to\ be\ resolved\ at\ formatting\ time.}}
\DoxyCodeLine{00442\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ ParseContext>}
\DoxyCodeLine{00443\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classunits_1_1detail_1_1dynamic__specs__handler}{dynamic\_specs\_handler}}\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{classunits_1_1detail_1_1specs__setter}{specs\_setter}}<typename\ ParseContext::char\_type>\ \{}
\DoxyCodeLine{00444\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00445\ \ \ \textcolor{keyword}{using\ }char\_type\ =\ TYPENAME\ ParseContext::char\_type;}
\DoxyCodeLine{00446\ }
\DoxyCodeLine{00447\ \ \ \textcolor{keyword}{constexpr}\ \mbox{\hyperlink{classunits_1_1detail_1_1dynamic__specs__handler}{dynamic\_specs\_handler}}(\mbox{\hyperlink{structunits_1_1detail_1_1dynamic__format__specs}{dynamic\_format\_specs<char\_type>}}\&\ specs,\ ParseContext\&\ ctx)\ :}
\DoxyCodeLine{00448\ \ \ \ \ \ \ \mbox{\hyperlink{classunits_1_1detail_1_1specs__setter}{specs\_setter<char\_type>}}(specs),\ specs\_(specs),\ context\_(ctx)}
\DoxyCodeLine{00449\ \ \ \{}
\DoxyCodeLine{00450\ \ \ \}}
\DoxyCodeLine{00451\ }
\DoxyCodeLine{00452\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00453\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_dynamic\_width(T\ t)}
\DoxyCodeLine{00454\ \ \ \{}
\DoxyCodeLine{00455\ \ \ \ \ specs\_.dynamic\_width\_index\ =\ on\_dynamic\_arg(t,\ context\_);}
\DoxyCodeLine{00456\ \ \ \}}
\DoxyCodeLine{00457\ }
\DoxyCodeLine{00458\ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00459\ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{void}\ on\_dynamic\_precision(T\ t)}
\DoxyCodeLine{00460\ \ \ \{}
\DoxyCodeLine{00461\ \ \ \ \ specs\_.dynamic\_precision\_index\ =\ on\_dynamic\_arg(t,\ context\_);}
\DoxyCodeLine{00462\ \ \ \}}
\DoxyCodeLine{00463\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00464\ \ \ \mbox{\hyperlink{structunits_1_1detail_1_1dynamic__format__specs}{dynamic\_format\_specs<char\_type>}}\&\ specs\_;}
\DoxyCodeLine{00465\ \ \ ParseContext\&\ context\_;}
\DoxyCodeLine{00466\ \};}
\DoxyCodeLine{00467\ }
\DoxyCodeLine{00468\ \}\ \ \textcolor{comment}{//\ namespace\ units::detail}}

\end{DoxyCode}
